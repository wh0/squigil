<!-- Copyright (C) Microsoft Corporation. All rights reserved. -->
<!DOCTYPE html>
<html>
	<head>
		<script>
			performance.mark('code/didStartRenderer')
		</script>
		<meta charset="utf-8" />

		<!-- Mobile tweaks -->
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-title" content="Code">
		<link rel="apple-touch-icon" href="/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/code-192.png" />

		<!-- Disable pinch zooming -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">

		<!-- Workbench Configuration -->
		<meta id="vscode-workbench-web-configuration" data-settings="{
			&quot;developmentOptions&quot;: {
				&quot;extensions&quot;: [
					{&quot;scheme&quot;: &quot;http&quot;, &quot;authority&quot;: &quot;localhost:7676&quot;, &quot;path&quot;: &quot;/workbench-ext&quot;}
				]
			},
			&quot;folderUri&quot;: {&quot;scheme&quot;: &quot;squigil&quot;, &quot;authority&quot;: &quot;127.0.0.1:7676&quot;, &quot;path&quot;: &quot;/&quot;},
			&quot;configurationDefaults&quot;: {
				&quot;squigil.adminBaseOverrides&quot;: {
					&quot;127.0.0.1:7676&quot;: &quot;http://127.0.0.1:7676/admin/~&quot;
				}
			},
			&quot;productConfiguration&quot;: {
				&quot;extensionsGallery&quot;: {
					&quot;resourceUrlTemplate&quot;: &quot;http://localhost:7676/vscode-unpkg/~/{publisher}/{publisher}/{name}/{version}/{path}&quot;,
					&quot;extensionUrlTemplate&quot;: &quot;http://localhost:7676/vscode-unpkg/~/www/_gallery/{publisher}/{name}/latest&quot;
				}
			}
		}">

		<!-- Builtin Extensions (running out of sources) -->
		<meta id="vscode-workbench-builtin-extensions" data-settings="[]">

		<!-- Workbench Icon/Manifest/CSS -->
		<link rel="icon" href="/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/favicon.ico" type="image/x-icon" />
		<link rel="manifest" href="/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/manifest.json">

		<link data-name="vs/workbench/workbench.web.main" rel="stylesheet" href="/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/out/vs/workbench/workbench.web.main.css" />
		<style id="vscode-css-modules" type="text/css" media="screen"></style>
	</head>

	<body aria-label="">
	</body>

	<!-- Startup (do not modify order of script tags!) -->
	<script>
		// BASE URL
		const baseUrl = new URL('/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92', window.location.origin).toString();
		globalThis._VSCODE_FILE_ROOT = baseUrl + '/out/';
	</script>
	<script>
		performance.mark('code/willLoadWorkbenchMain');
	</script>
	<script src="/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/out/nls.messages.js"></script>
	<script type="module">
		/*---------------------------------------------------------------------------------------------
		*  Copyright (c) Microsoft Corporation. All rights reserved.
		*  Licensed under the MIT License. See License.txt in the project root for license information.
		*--------------------------------------------------------------------------------------------*/
		///<amd-module name='vscode-web-browser-main'/>
		import { create, URI, Emitter } from '/vscode-cdn/~/stable/e3a5acfb517a443235981655413d566533107e92/out/vs/workbench/workbench.web.main.internal.js';
		class WorkspaceProvider {
			static { this.QUERY_PARAM_EMPTY_WINDOW = 'ew'; }
			static { this.QUERY_PARAM_FOLDER = 'folder'; }
			static { this.QUERY_PARAM_WORKSPACE = 'workspace'; }
			static { this.QUERY_PARAM_PAYLOAD = 'payload'; }
			static create(config) {
				let foundWorkspace = false;
				let workspace;
				let payload = Object.create(null);
				const query = new URL(document.location.href).searchParams;
				query.forEach((value, key) => {
					switch (key) {
						// Folder
						case WorkspaceProvider.QUERY_PARAM_FOLDER:
							workspace = { folderUri: URI.parse(value) };
							foundWorkspace = true;
							break;
						// Workspace
						case WorkspaceProvider.QUERY_PARAM_WORKSPACE:
							workspace = { workspaceUri: URI.parse(value) };
							foundWorkspace = true;
							break;
						// Empty
						case WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:
							workspace = undefined;
							foundWorkspace = true;
							break;
						// Payload
						case WorkspaceProvider.QUERY_PARAM_PAYLOAD:
							try {
								payload = JSON.parse(value);
							}
							catch (error) {
								console.error(error); // possible invalid JSON
							}
							break;
					}
				});
				// If no workspace is provided through the URL, check for config
				// attribute from server
				if (!foundWorkspace) {
					if (config.folderUri) {
						workspace = { folderUri: URI.revive(config.folderUri) };
					}
					else if (config.workspaceUri) {
						workspace = { workspaceUri: URI.revive(config.workspaceUri) };
					}
				}
				return new WorkspaceProvider(workspace, payload);
			}
			constructor(workspace, payload) {
				this.workspace = workspace;
				this.payload = payload;
				this.trusted = true;
			}
			async open(workspace, options) {
				if (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {
					return true; // return early if workspace and environment is not changing and we are reusing window
				}
				const targetHref = this.createTargetUrl(workspace, options);
				if (targetHref) {
					if (options?.reuse) {
						window.location.href = targetHref;
						return true;
					}
					else {
						return !!window.open(targetHref);
					}
				}
				return false;
			}
			createTargetUrl(workspace, options) {
				// Empty
				let targetHref = undefined;
				if (!workspace) {
					targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;
				}
				// Folder
				else if ('folderUri' in workspace) {
					const queryParamFolder = encodeURIComponent(workspace.folderUri.toString(true));
					targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${queryParamFolder}`;
				}
				// Workspace
				else if ('workspaceUri' in workspace) {
					const queryParamWorkspace = encodeURIComponent(workspace.workspaceUri.toString(true));
					targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${queryParamWorkspace}`;
				}
				// Append payload if any
				if (options?.payload) {
					targetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;
				}
				return targetHref;
			}
			isSame(workspaceA, workspaceB) {
				if (!workspaceA || !workspaceB) {
					return workspaceA === workspaceB; // both empty
				}
				if ('folderUri' in workspaceA && 'folderUri' in workspaceB) {
					return this.isEqualURI(workspaceA.folderUri, workspaceB.folderUri); // same workspace
				}
				if ('workspaceUri' in workspaceA && 'workspaceUri' in workspaceB) {
					return this.isEqualURI(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace
				}
				return false;
			}
			isEqualURI(a, b) {
				return a.scheme === b.scheme && a.authority === b.authority && a.path === b.path;
			}
		}
		class LocalStorageURLCallbackProvider {
			static { this.REQUEST_ID = 0; }
			static { this.QUERY_KEYS = [
				'scheme',
				'authority',
				'path',
				'query',
				'fragment'
			]; }
			constructor(_callbackRoute) {
				this._callbackRoute = _callbackRoute;
				this._onCallback = new Emitter();
				this.onCallback = this._onCallback.event;
				this.pendingCallbacks = new Set();
				this.lastTimeChecked = Date.now();
				this.checkCallbacksTimeout = undefined;
			}
			create(options = {}) {
				const id = ++LocalStorageURLCallbackProvider.REQUEST_ID;
				const queryParams = [`vscode-reqid=${id}`];
				for (const key of LocalStorageURLCallbackProvider.QUERY_KEYS) {
					const value = options[key];
					if (value) {
						queryParams.push(`vscode-${key}=${encodeURIComponent(value)}`);
					}
				}
				// TODO@joao remove eventually
				// https://github.com/microsoft/vscode-dev/issues/62
				// https://github.com/microsoft/vscode/blob/159479eb5ae451a66b5dac3c12d564f32f454796/extensions/github-authentication/src/githubServer.ts#L50-L50
				if (!(options.authority === 'vscode.github-authentication' && options.path === '/dummy')) {
					const key = `vscode-web.url-callbacks[${id}]`;
					localStorage.removeItem(key);
					this.pendingCallbacks.add(id);
					this.startListening();
				}
				return URI.parse(window.location.href).with({ path: this._callbackRoute, query: queryParams.join('&') });
			}
			startListening() {
				if (this.onDidChangeLocalStorageDisposable) {
					return;
				}
				const fn = () => this.onDidChangeLocalStorage();
				window.addEventListener('storage', fn);
				this.onDidChangeLocalStorageDisposable = { dispose: () => window.removeEventListener('storage', fn) };
			}
			stopListening() {
				this.onDidChangeLocalStorageDisposable?.dispose();
				this.onDidChangeLocalStorageDisposable = undefined;
			}
			// this fires every time local storage changes, but we
			// don't want to check more often than once a second
			async onDidChangeLocalStorage() {
				const ellapsed = Date.now() - this.lastTimeChecked;
				if (ellapsed > 1000) {
					this.checkCallbacks();
				}
				else if (this.checkCallbacksTimeout === undefined) {
					this.checkCallbacksTimeout = setTimeout(() => {
						this.checkCallbacksTimeout = undefined;
						this.checkCallbacks();
					}, 1000 - ellapsed);
				}
			}
			checkCallbacks() {
				let pendingCallbacks;
				for (const id of this.pendingCallbacks) {
					const key = `vscode-web.url-callbacks[${id}]`;
					const result = localStorage.getItem(key);
					if (result !== null) {
						try {
							this._onCallback.fire(URI.revive(JSON.parse(result)));
						}
						catch (error) {
							console.error(error);
						}
						pendingCallbacks = pendingCallbacks ?? new Set(this.pendingCallbacks);
						pendingCallbacks.delete(id);
						localStorage.removeItem(key);
					}
				}
				if (pendingCallbacks) {
					this.pendingCallbacks = pendingCallbacks;
					if (this.pendingCallbacks.size === 0) {
						this.stopListening();
					}
				}
				this.lastTimeChecked = Date.now();
			}
			dispose() {
				this._onCallback.dispose();
			}
		}
		(function () {
			const configElement = window.document.getElementById('vscode-workbench-web-configuration');
			const configElementAttribute = configElement ? configElement.getAttribute('data-settings') : undefined;
			if (!configElement || !configElementAttribute) {
				throw new Error('Missing web configuration element');
			}
			const config = JSON.parse(configElementAttribute);
			create(window.document.body, {
				...config,
				workspaceProvider: WorkspaceProvider.create(config),
				urlCallbackProvider: new LocalStorageURLCallbackProvider(config.callbackRoute)
			});
		})();
	</script>
</html>
